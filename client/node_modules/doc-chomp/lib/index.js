'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = DocChomp;

var _literalToast = require('literal-toast');

var _literalToast2 = _interopRequireDefault(_literalToast);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NEW_LINE = '\n';


function DocChompInternal() {
  var indentString = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var lineToDetectFrom = arguments[1];

  for (var _len = arguments.length, templateLiteral = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    templateLiteral[_key - 2] = arguments[_key];
  }

  // Bake the document, split into lines
  var documentLines = _literalToast2.default.apply(undefined, templateLiteral).split(NEW_LINE);

  // Grab a trimmed version of the first line to determine whether to consider it empty
  var trimmedFirstLine = documentLines[0].trim();

  // Configuration: Determine whether we should be detecting indentation automatically
  var detectFromFirstIndentedLine = true;

  if (typeof lineToDetectFrom !== 'number') {
    // if `lineToDetectFrom` isn't a number, it's fallen back to the default of zero,
    // and we should see if there's a predefined indentation to decide whether to detect
    // the indentation automatically,
    lineToDetectFrom = 0;
    detectFromFirstIndentedLine = !indentString;
  } else {
    // if `lineToDetectFrom` is a number we don!
    detectFromFirstIndentedLine = false;
  }

  // If the first line isn't blank, that's no good 🙅🏻
  if (detectFromFirstIndentedLine && trimmedFirstLine) {
    throw new Error('doc-chomp: Text supplied on first line! Indentation cannot be reliably determined automatically.');
  }

  // Trim the first line if it's blank and we haven't bailed already!
  documentLines = documentLines.slice(!detectFromFirstIndentedLine && trimmedFirstLine ? 0 : 1);

  // If we don't already know what we're trimming, grab the leading indentation from the specified line
  if (!indentString) {
    indentString = documentLines[lineToDetectFrom].match(/^\s*/).shift();
  }

  // Replace the indentation and sew the document back together
  return documentLines.map(function (documentLine) {
    return documentLine.replace(indentString, '');
  }).join(NEW_LINE);
}

function DocChomp(maybeConfig) {
  if (typeof maybeConfig === 'string') {
    // String arguments are treated as overridden indentation definitions
    return DocChompInternal.bind(this, maybeConfig, undefined);
  } else if (typeof maybeConfig === 'number') {
    // Number arguments are treated as the line to measure indentation from
    return DocChompInternal.bind(this, undefined, maybeConfig);
  } else {
    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    // Otherwise, we are being used as a tag directly, so use defaults
    return DocChompInternal.call.apply(DocChompInternal, [this, undefined, undefined, maybeConfig].concat(args));
  }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJEb2NDaG9tcCIsIk5FV19MSU5FIiwiRG9jQ2hvbXBJbnRlcm5hbCIsImluZGVudFN0cmluZyIsImxpbmVUb0RldGVjdEZyb20iLCJ0ZW1wbGF0ZUxpdGVyYWwiLCJkb2N1bWVudExpbmVzIiwic3BsaXQiLCJ0cmltbWVkRmlyc3RMaW5lIiwidHJpbSIsImRldGVjdEZyb21GaXJzdEluZGVudGVkTGluZSIsIkVycm9yIiwic2xpY2UiLCJtYXRjaCIsInNoaWZ0IiwibWFwIiwiZG9jdW1lbnRMaW5lIiwicmVwbGFjZSIsImpvaW4iLCJtYXliZUNvbmZpZyIsImJpbmQiLCJ1bmRlZmluZWQiLCJhcmdzIiwiY2FsbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7a0JBK0N3QkEsUTs7QUE5Q3hCOzs7Ozs7QUFEQSxJQUFNQyxXQUFXLElBQWpCOzs7QUFHQSxTQUFTQyxnQkFBVCxHQUFtRjtBQUFBLE1BQXpEQyxZQUF5RCx1RUFBMUMsRUFBMEM7QUFBQSxNQUF0Q0MsZ0JBQXNDOztBQUFBLG9DQUFqQkMsZUFBaUI7QUFBakJBLG1CQUFpQjtBQUFBOztBQUNqRjtBQUNBLE1BQUlDLGdCQUFnQix3Q0FBZ0JELGVBQWhCLEVBQWlDRSxLQUFqQyxDQUF1Q04sUUFBdkMsQ0FBcEI7O0FBRUE7QUFDQSxNQUFNTyxtQkFBbUJGLGNBQWMsQ0FBZCxFQUFpQkcsSUFBakIsRUFBekI7O0FBRUE7QUFDQSxNQUFJQyw4QkFBOEIsSUFBbEM7O0FBRUEsTUFBSSxPQUFPTixnQkFBUCxLQUE0QixRQUFoQyxFQUEwQztBQUN4QztBQUNBO0FBQ0E7QUFDQUEsdUJBQW1CLENBQW5CO0FBQ0FNLGtDQUE4QixDQUFDUCxZQUEvQjtBQUNELEdBTkQsTUFNTztBQUNMO0FBQ0FPLGtDQUE4QixLQUE5QjtBQUNEOztBQUVEO0FBQ0EsTUFBSUEsK0JBQStCRixnQkFBbkMsRUFBcUQ7QUFDbkQsVUFBTSxJQUFJRyxLQUFKLG9HQUFOO0FBQ0Q7O0FBRUQ7QUFDQUwsa0JBQWdCQSxjQUFjTSxLQUFkLENBQ2QsQ0FBQ0YsMkJBQUQsSUFBZ0NGLGdCQUFoQyxHQUNJLENBREosR0FFSSxDQUhVLENBQWhCOztBQU1BO0FBQ0EsTUFBSSxDQUFDTCxZQUFMLEVBQW1CO0FBQ2pCQSxtQkFBZUcsY0FBY0YsZ0JBQWQsRUFBZ0NTLEtBQWhDLENBQXNDLE1BQXRDLEVBQThDQyxLQUE5QyxFQUFmO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFPUixjQUNKUyxHQURJLENBQ0EsVUFBQ0MsWUFBRDtBQUFBLFdBQWtCQSxhQUFhQyxPQUFiLENBQXFCZCxZQUFyQixFQUFtQyxFQUFuQyxDQUFsQjtBQUFBLEdBREEsRUFFSmUsSUFGSSxDQUVDakIsUUFGRCxDQUFQO0FBR0Q7O0FBRWMsU0FBU0QsUUFBVCxDQUFrQm1CLFdBQWxCLEVBQXdDO0FBQ3JELE1BQUksT0FBT0EsV0FBUCxLQUF1QixRQUEzQixFQUFxQztBQUNuQztBQUNBLFdBQU9qQixpQkFBaUJrQixJQUFqQixDQUFzQixJQUF0QixFQUE0QkQsV0FBNUIsRUFBeUNFLFNBQXpDLENBQVA7QUFDRCxHQUhELE1BR08sSUFBSSxPQUFPRixXQUFQLEtBQXVCLFFBQTNCLEVBQXFDO0FBQzFDO0FBQ0EsV0FBT2pCLGlCQUFpQmtCLElBQWpCLENBQXNCLElBQXRCLEVBQTRCQyxTQUE1QixFQUF1Q0YsV0FBdkMsQ0FBUDtBQUNELEdBSE0sTUFHQTtBQUFBLHVDQVB3Q0csSUFPeEM7QUFQd0NBLFVBT3hDO0FBQUE7O0FBQ0w7QUFDQSxXQUFPcEIsaUJBQWlCcUIsSUFBakIsMEJBQXNCLElBQXRCLEVBQTRCRixTQUE1QixFQUF1Q0EsU0FBdkMsRUFBa0RGLFdBQWxELFNBQWtFRyxJQUFsRSxFQUFQO0FBQ0Q7QUFDRiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE5FV19MSU5FID0gJ1xcbic7XG5pbXBvcnQgbGl0ZXJhbFRvYXN0IGZyb20gJ2xpdGVyYWwtdG9hc3QnO1xuXG5mdW5jdGlvbiBEb2NDaG9tcEludGVybmFsKGluZGVudFN0cmluZyA9ICcnLCBsaW5lVG9EZXRlY3RGcm9tLCAuLi50ZW1wbGF0ZUxpdGVyYWwpIHtcbiAgLy8gQmFrZSB0aGUgZG9jdW1lbnQsIHNwbGl0IGludG8gbGluZXNcbiAgbGV0IGRvY3VtZW50TGluZXMgPSBsaXRlcmFsVG9hc3QoLi4udGVtcGxhdGVMaXRlcmFsKS5zcGxpdChORVdfTElORSk7XG5cbiAgLy8gR3JhYiBhIHRyaW1tZWQgdmVyc2lvbiBvZiB0aGUgZmlyc3QgbGluZSB0byBkZXRlcm1pbmUgd2hldGhlciB0byBjb25zaWRlciBpdCBlbXB0eVxuICBjb25zdCB0cmltbWVkRmlyc3RMaW5lID0gZG9jdW1lbnRMaW5lc1swXS50cmltKCk7XG5cbiAgLy8gQ29uZmlndXJhdGlvbjogRGV0ZXJtaW5lIHdoZXRoZXIgd2Ugc2hvdWxkIGJlIGRldGVjdGluZyBpbmRlbnRhdGlvbiBhdXRvbWF0aWNhbGx5XG4gIGxldCBkZXRlY3RGcm9tRmlyc3RJbmRlbnRlZExpbmUgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgbGluZVRvRGV0ZWN0RnJvbSAhPT0gJ251bWJlcicpIHtcbiAgICAvLyBpZiBgbGluZVRvRGV0ZWN0RnJvbWAgaXNuJ3QgYSBudW1iZXIsIGl0J3MgZmFsbGVuIGJhY2sgdG8gdGhlIGRlZmF1bHQgb2YgemVybyxcbiAgICAvLyBhbmQgd2Ugc2hvdWxkIHNlZSBpZiB0aGVyZSdzIGEgcHJlZGVmaW5lZCBpbmRlbnRhdGlvbiB0byBkZWNpZGUgd2hldGhlciB0byBkZXRlY3RcbiAgICAvLyB0aGUgaW5kZW50YXRpb24gYXV0b21hdGljYWxseSxcbiAgICBsaW5lVG9EZXRlY3RGcm9tID0gMDtcbiAgICBkZXRlY3RGcm9tRmlyc3RJbmRlbnRlZExpbmUgPSAhaW5kZW50U3RyaW5nO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIGBsaW5lVG9EZXRlY3RGcm9tYCBpcyBhIG51bWJlciB3ZSBkb24hXG4gICAgZGV0ZWN0RnJvbUZpcnN0SW5kZW50ZWRMaW5lID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiB0aGUgZmlyc3QgbGluZSBpc24ndCBibGFuaywgdGhhdCdzIG5vIGdvb2Qg8J+ZhfCfj7tcbiAgaWYgKGRldGVjdEZyb21GaXJzdEluZGVudGVkTGluZSAmJiB0cmltbWVkRmlyc3RMaW5lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBkb2MtY2hvbXA6IFRleHQgc3VwcGxpZWQgb24gZmlyc3QgbGluZSEgSW5kZW50YXRpb24gY2Fubm90IGJlIHJlbGlhYmx5IGRldGVybWluZWQgYXV0b21hdGljYWxseS5gKTtcbiAgfVxuXG4gIC8vIFRyaW0gdGhlIGZpcnN0IGxpbmUgaWYgaXQncyBibGFuayBhbmQgd2UgaGF2ZW4ndCBiYWlsZWQgYWxyZWFkeSFcbiAgZG9jdW1lbnRMaW5lcyA9IGRvY3VtZW50TGluZXMuc2xpY2UoXG4gICAgIWRldGVjdEZyb21GaXJzdEluZGVudGVkTGluZSAmJiB0cmltbWVkRmlyc3RMaW5lXG4gICAgICA/IDBcbiAgICAgIDogMVxuICApO1xuXG4gIC8vIElmIHdlIGRvbid0IGFscmVhZHkga25vdyB3aGF0IHdlJ3JlIHRyaW1taW5nLCBncmFiIHRoZSBsZWFkaW5nIGluZGVudGF0aW9uIGZyb20gdGhlIHNwZWNpZmllZCBsaW5lXG4gIGlmICghaW5kZW50U3RyaW5nKSB7XG4gICAgaW5kZW50U3RyaW5nID0gZG9jdW1lbnRMaW5lc1tsaW5lVG9EZXRlY3RGcm9tXS5tYXRjaCgvXlxccyovKS5zaGlmdCgpO1xuICB9XG5cbiAgLy8gUmVwbGFjZSB0aGUgaW5kZW50YXRpb24gYW5kIHNldyB0aGUgZG9jdW1lbnQgYmFjayB0b2dldGhlclxuICByZXR1cm4gZG9jdW1lbnRMaW5lc1xuICAgIC5tYXAoKGRvY3VtZW50TGluZSkgPT4gZG9jdW1lbnRMaW5lLnJlcGxhY2UoaW5kZW50U3RyaW5nLCAnJykpXG4gICAgLmpvaW4oTkVXX0xJTkUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEb2NDaG9tcChtYXliZUNvbmZpZywgLi4uYXJncykge1xuICBpZiAodHlwZW9mIG1heWJlQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIC8vIFN0cmluZyBhcmd1bWVudHMgYXJlIHRyZWF0ZWQgYXMgb3ZlcnJpZGRlbiBpbmRlbnRhdGlvbiBkZWZpbml0aW9uc1xuICAgIHJldHVybiBEb2NDaG9tcEludGVybmFsLmJpbmQodGhpcywgbWF5YmVDb25maWcsIHVuZGVmaW5lZCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1heWJlQ29uZmlnID09PSAnbnVtYmVyJykge1xuICAgIC8vIE51bWJlciBhcmd1bWVudHMgYXJlIHRyZWF0ZWQgYXMgdGhlIGxpbmUgdG8gbWVhc3VyZSBpbmRlbnRhdGlvbiBmcm9tXG4gICAgcmV0dXJuIERvY0Nob21wSW50ZXJuYWwuYmluZCh0aGlzLCB1bmRlZmluZWQsIG1heWJlQ29uZmlnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2UsIHdlIGFyZSBiZWluZyB1c2VkIGFzIGEgdGFnIGRpcmVjdGx5LCBzbyB1c2UgZGVmYXVsdHNcbiAgICByZXR1cm4gRG9jQ2hvbXBJbnRlcm5hbC5jYWxsKHRoaXMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtYXliZUNvbmZpZywgLi4uYXJncyk7XG4gIH1cbn1cbiJdfQ==