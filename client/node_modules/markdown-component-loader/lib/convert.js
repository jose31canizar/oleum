'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _frontMatter2 = require('front-matter');

var _frontMatter3 = _interopRequireDefault(_frontMatter2);

var _hastml = require('hastml');

var _hastml2 = _interopRequireDefault(_hastml);

var _he = require('he');

var _highlight = require('highlight.js');

var _highlight2 = _interopRequireDefault(_highlight);

var _jsxFriendlyMarkdownIt = require('./jsx-friendly-markdown-it');

var _jsxFriendlyMarkdownIt2 = _interopRequireDefault(_jsxFriendlyMarkdownIt);

var _module = require('./formatters/module');

var _module2 = _interopRequireDefault(_module);

var _jsEscape = require('./formatters/js-escape');

var _jsEscape2 = _interopRequireDefault(_jsEscape);

var _stringReplacementCache = require('./string-replacement-cache');

var _stringReplacementCache2 = _interopRequireDefault(_stringReplacementCache);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var ASSIGNMENT_EXPRESSION_PREFIX = 'mclAssignmentBeginI';
var ASSIGNMENT_EXPRESSION_SUFFIX = 'IEnd';
var ASSIGNMENT_EXPRESSION_REGEXP =
// Assignment Expression IDs are 55 lower-case characters long
ASSIGNMENT_EXPRESSION_PREFIX + '[a-z]{55}' + ASSIGNMENT_EXPRESSION_SUFFIX;
var ASSIGNMENT_EXPRESSION_COMMENT_REGEXP = '{/\\*(' + ASSIGNMENT_EXPRESSION_REGEXP + ')\\*/}';

var IMPLICIT_REACT_IMPORTS = {
  React: 'react',
  PropTypes: 'prop-types'
};

var DEFAULT_CONFIGURATION = {
  implicitlyImportReact: true,
  passElementProps: false,
  markdownItPlugins: []
};

exports.default = function (source, config) {
  // First, we handle the configuration and front-matter

  config = Object.assign({}, DEFAULT_CONFIGURATION, config);

  var invalidStatics = ['propTypes'];

  // Pull out imports & front-matter

  var _frontMatter = (0, _frontMatter3.default)(source),
      markdown = _frontMatter.body,
      _frontMatter$attribut = _frontMatter.attributes,
      customImports = _frontMatter$attribut.imports,
      statics = _objectWithoutProperties(_frontMatter$attribut, ['imports']);

  // Import React and PropTypes unless we've been asked otherwise


  var imports = config.implicitlyImportReact ? _extends({}, IMPLICIT_REACT_IMPORTS, customImports) : customImports;

  // Disallow passing `defaultProps` if we're passing our own
  if (config.passElementProps) {
    invalidStatics.push('defaultProps');
  }

  // Check for invalid statics
  Object.keys(statics).map(function (attribute) {
    if (invalidStatics.indexOf(attribute) !== -1) {
      throw new Error('You can\'t supply a `' + attribute + '` static! That name is reserved.');
    }
  });

  // Now, we start processing the markdown itself

  // Hold onto JSX properties and assignment expressions before converting
  var offsetForPropertyReplacements = 0;
  var markdownSansJsxProperties = markdown;

  var jsxPropertyCache = new _stringReplacementCache2.default(/[\w]+={[^}]*}\s*}?|{\s*\.\.\.[^}]*}/g);

  // Find all opening or void HTML tags
  (0, _hastml2.default)(markdown, function (match, tagFragment, offset, string, tag) {
    // Once we get a tag which is closing
    if (typeof tag.closeIndex === 'number') {
      // Replace any assignment expressions within its opening tag
      var startIndex = tag.openIndex + offsetForPropertyReplacements;
      var endIndex = (typeof tag.contentIndex === 'number' ? tag.contentIndex : tag.closeIndex) + offsetForPropertyReplacements;

      var tagWithNoReplacements = markdownSansJsxProperties.slice(startIndex, endIndex);
      var tagWithPropertyReplacements = jsxPropertyCache.load(tagWithNoReplacements);

      markdownSansJsxProperties = markdownSansJsxProperties.slice(0, startIndex) + tagWithPropertyReplacements + markdownSansJsxProperties.slice(endIndex);

      offsetForPropertyReplacements += tagWithPropertyReplacements.length - tagWithNoReplacements.length;
    }
  });

  // Replace all remaining double-brace assignment expressions with comments
  var assignmentExpressionCache = new _stringReplacementCache2.default(/{({\s*(?:<.*?>|.*?)\s*})}/g, function (match, value) {
    return value;
  }, function (identityHash) {
    return '' + ASSIGNMENT_EXPRESSION_PREFIX + identityHash + ASSIGNMENT_EXPRESSION_SUFFIX;
  });

  var markdownSansAssignments = assignmentExpressionCache.load(markdownSansJsxProperties);

  // Configure Markdown renderer, highlight code snippets, and post-process
  var renderer = new _jsxFriendlyMarkdownIt2.default().configure('commonmark').enable(['smartquotes']).set({
    // We need explicit line breaks
    breaks: true,
    typographer: config.typographer,
    highlight: function highlight(code, languageHint) {
      var highlightedContent = void 0;

      _highlight2.default.configure({ tabReplace: '  ' });

      // Try highlighting with a given hint
      if (languageHint && _highlight2.default.getLanguage(languageHint)) {
        try {
          highlightedContent = _highlight2.default.highlight(languageHint, code).value;
        } catch (err) {} // eslint-disable-line no-empty
      }

      // Highlight without a hint
      if (!highlightedContent) {
        try {
          highlightedContent = _highlight2.default.highlightAuto(code).value;
        } catch (err) {} // eslint-disable-line no-empty
      }

      return highlightedContent.replace(/\n/g, '<br />');
    }
  });

  // Load MarkdownIt plugins
  if (config.markdownItPlugins && Array.isArray(config.markdownItPlugins)) {
    renderer = config.markdownItPlugins.reduce(function (markdownRenderer, pluginDefinition) {
      if (!Array.isArray(pluginDefinition)) {
        pluginDefinition = [pluginDefinition];
      }
      if (typeof pluginDefinition[0] === 'string') {
        pluginDefinition[0] = require(pluginDefinition[0]);
      }
      return markdownRenderer.use.apply(markdownRenderer, _toConsumableArray(pluginDefinition));
    }, renderer);
  }

  // Render markdown to HTML, and replace assignment expressions with comments
  var html = (renderer.render(markdownSansAssignments) || '<!-- no input given -->').replace(new RegExp(ASSIGNMENT_EXPRESSION_REGEXP, 'g'), '<!--$&-->');

  // Collect all the HTML tags and their positions
  var htmlOffsets = [0];

  (0, _hastml2.default)(html, function (match, tagFragment, offset) {
    if (tagFragment[0] === '<') {
      // Push the offset of opening tags...
      htmlOffsets.push(offset);
    } else {
      // âˆ´ tagFragment[tagFragment.length - 1] === '>'
      // ...and the end offset of closing tags
      htmlOffsets.push(offset + tagFragment.length);
    }
  });

  // Here, we collect all the positions at which HTML tags begin or end
  var jsx = htmlOffsets.map(function (offset, index, array) {
    var fragment = html.slice(offset, array[index + 1]);

    // Then we check, for each of them, whether they are a tag or a text node
    if (fragment[0] === '<' || fragment[fragment.length - 1] === '>') {
      // If they're tags, we check whether they're a comment,
      if (fragment.slice(0, 4) === '<!--') {
        // and replace them with JSX style comments
        return '{/*' + fragment.slice(4, -3) + '*/}';
      } else {
        // otherwise, we will...
        if (fragment[1] !== '/') {
          // ...replace `class` properties with `className` for React compatibility
          fragment = fragment.replace(/(\sclass)(=)/, '$1Name$2');

          // and, if we've been asked to, add the `elementProps` pass-through.
          if (config.passElementProps) {
            var tagName = fragment.slice(1, fragment.search(/[\s\n]/));

            return fragment.replace(/(\s*\/?>)/, ' {...elementProps[' + (0, _jsEscape2.default)(tagName) + ']}$1');
          }
        }
      }
    } else {
      // If they're not tags, they're a text node. We split on newlines, and...
      return fragment.split(/\n/g).map(function (line) {
        // ...wrap string lines containing curly braces

        if (line.indexOf('{') !== -1 || line.indexOf('}') !== -1) {
          return '{' + (0, _jsEscape2.default)((0, _he.decode)(line)) + '}';
        }

        return line;
      }).join('\n');
    }

    // fall back to returning input
    return fragment;
  })
  // Put it all back together,
  .join('')
  // Restore assignment expressions to their original form
  .replace(new RegExp(ASSIGNMENT_EXPRESSION_COMMENT_REGEXP, 'g'), '$1')
  // Indent for pretty inspector output ðŸŽ‰
  .replace(/\n/g, '\n          ')
  // And remove the trailing blank line
  .replace(/\n\s*$/g, '');

  // Unload caches so we've got our values back!
  jsx = jsxPropertyCache.unload(assignmentExpressionCache.unload(jsx));

  return (0, _module2.default)(imports, statics, jsx, config);
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb252ZXJ0LmpzIl0sIm5hbWVzIjpbIkFTU0lHTk1FTlRfRVhQUkVTU0lPTl9QUkVGSVgiLCJBU1NJR05NRU5UX0VYUFJFU1NJT05fU1VGRklYIiwiQVNTSUdOTUVOVF9FWFBSRVNTSU9OX1JFR0VYUCIsIkFTU0lHTk1FTlRfRVhQUkVTU0lPTl9DT01NRU5UX1JFR0VYUCIsIklNUExJQ0lUX1JFQUNUX0lNUE9SVFMiLCJSZWFjdCIsIlByb3BUeXBlcyIsIkRFRkFVTFRfQ09ORklHVVJBVElPTiIsImltcGxpY2l0bHlJbXBvcnRSZWFjdCIsInBhc3NFbGVtZW50UHJvcHMiLCJtYXJrZG93bkl0UGx1Z2lucyIsInNvdXJjZSIsImNvbmZpZyIsIk9iamVjdCIsImFzc2lnbiIsImludmFsaWRTdGF0aWNzIiwibWFya2Rvd24iLCJib2R5IiwiYXR0cmlidXRlcyIsImN1c3RvbUltcG9ydHMiLCJpbXBvcnRzIiwic3RhdGljcyIsInB1c2giLCJrZXlzIiwibWFwIiwiYXR0cmlidXRlIiwiaW5kZXhPZiIsIkVycm9yIiwib2Zmc2V0Rm9yUHJvcGVydHlSZXBsYWNlbWVudHMiLCJtYXJrZG93blNhbnNKc3hQcm9wZXJ0aWVzIiwianN4UHJvcGVydHlDYWNoZSIsIm1hdGNoIiwidGFnRnJhZ21lbnQiLCJvZmZzZXQiLCJzdHJpbmciLCJ0YWciLCJjbG9zZUluZGV4Iiwic3RhcnRJbmRleCIsIm9wZW5JbmRleCIsImVuZEluZGV4IiwiY29udGVudEluZGV4IiwidGFnV2l0aE5vUmVwbGFjZW1lbnRzIiwic2xpY2UiLCJ0YWdXaXRoUHJvcGVydHlSZXBsYWNlbWVudHMiLCJsb2FkIiwibGVuZ3RoIiwiYXNzaWdubWVudEV4cHJlc3Npb25DYWNoZSIsInZhbHVlIiwiaWRlbnRpdHlIYXNoIiwibWFya2Rvd25TYW5zQXNzaWdubWVudHMiLCJyZW5kZXJlciIsImNvbmZpZ3VyZSIsImVuYWJsZSIsInNldCIsImJyZWFrcyIsInR5cG9ncmFwaGVyIiwiaGlnaGxpZ2h0IiwiY29kZSIsImxhbmd1YWdlSGludCIsImhpZ2hsaWdodGVkQ29udGVudCIsInRhYlJlcGxhY2UiLCJnZXRMYW5ndWFnZSIsImVyciIsImhpZ2hsaWdodEF1dG8iLCJyZXBsYWNlIiwiQXJyYXkiLCJpc0FycmF5IiwicmVkdWNlIiwibWFya2Rvd25SZW5kZXJlciIsInBsdWdpbkRlZmluaXRpb24iLCJyZXF1aXJlIiwidXNlIiwiaHRtbCIsInJlbmRlciIsIlJlZ0V4cCIsImh0bWxPZmZzZXRzIiwianN4IiwiaW5kZXgiLCJhcnJheSIsImZyYWdtZW50IiwidGFnTmFtZSIsInNlYXJjaCIsInNwbGl0IiwibGluZSIsImpvaW4iLCJ1bmxvYWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSwrQkFBK0IscUJBQXJDO0FBQ0EsSUFBTUMsK0JBQStCLE1BQXJDO0FBQ0EsSUFBTUM7QUFDSjtBQUNHRiw0QkFGQyxpQkFFdUNDLDRCQUY3QztBQUlBLElBQU1FLGtEQUNLRCw0QkFETCxXQUFOOztBQUlBLElBQU1FLHlCQUF5QjtBQUM3QkMsU0FBTyxPQURzQjtBQUU3QkMsYUFBVztBQUZrQixDQUEvQjs7QUFLQSxJQUFNQyx3QkFBd0I7QUFDNUJDLHlCQUF1QixJQURLO0FBRTVCQyxvQkFBa0IsS0FGVTtBQUc1QkMscUJBQW1CO0FBSFMsQ0FBOUI7O2tCQU1lLFVBQUNDLE1BQUQsRUFBU0MsTUFBVCxFQUFvQjtBQUNqQzs7QUFFQUEsV0FBU0MsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JQLHFCQUFsQixFQUF5Q0ssTUFBekMsQ0FBVDs7QUFFQSxNQUFNRyxpQkFBaUIsQ0FBQyxXQUFELENBQXZCOztBQUVBOztBQVBpQyxxQkFROEMsMkJBQVlKLE1BQVosQ0FSOUM7QUFBQSxNQVFuQkssUUFSbUIsZ0JBUXpCQyxJQVJ5QjtBQUFBLDJDQVFUQyxVQVJTO0FBQUEsTUFRY0MsYUFSZCx5QkFRS0MsT0FSTDtBQUFBLE1BUWdDQyxPQVJoQzs7QUFVakM7OztBQUNBLE1BQU1ELFVBQVVSLE9BQU9KLHFCQUFQLGdCQUNQSixzQkFETyxFQUNvQmUsYUFEcEIsSUFFWkEsYUFGSjs7QUFJQTtBQUNBLE1BQUlQLE9BQU9ILGdCQUFYLEVBQTZCO0FBQzNCTSxtQkFBZU8sSUFBZixDQUFvQixjQUFwQjtBQUNEOztBQUVEO0FBQ0FULFNBQU9VLElBQVAsQ0FBWUYsT0FBWixFQUFxQkcsR0FBckIsQ0FBeUIsVUFBQ0MsU0FBRCxFQUFlO0FBQ3RDLFFBQUlWLGVBQWVXLE9BQWYsQ0FBdUJELFNBQXZCLE1BQXNDLENBQUMsQ0FBM0MsRUFBOEM7QUFDNUMsWUFBTSxJQUFJRSxLQUFKLDJCQUNvQkYsU0FEcEIsc0NBQU47QUFHRDtBQUNGLEdBTkQ7O0FBUUE7O0FBRUE7QUFDQSxNQUFJRyxnQ0FBZ0MsQ0FBcEM7QUFDQSxNQUFJQyw0QkFBNEJiLFFBQWhDOztBQUVBLE1BQU1jLG1CQUFtQixxQ0FDdkIsc0NBRHVCLENBQXpCOztBQUlBO0FBQ0Esd0JBQ0VkLFFBREYsRUFFRSxVQUFDZSxLQUFELEVBQVFDLFdBQVIsRUFBcUJDLE1BQXJCLEVBQTZCQyxNQUE3QixFQUFxQ0MsR0FBckMsRUFBNkM7QUFDM0M7QUFDQSxRQUFJLE9BQU9BLElBQUlDLFVBQVgsS0FBMEIsUUFBOUIsRUFBd0M7QUFDdEM7QUFDQSxVQUFNQyxhQUFhRixJQUFJRyxTQUFKLEdBQWdCViw2QkFBbkM7QUFDQSxVQUFNVyxXQUFXLENBQ2YsT0FBT0osSUFBSUssWUFBWCxLQUE0QixRQUE1QixHQUNJTCxJQUFJSyxZQURSLEdBRUlMLElBQUlDLFVBSE8sSUFJYlIsNkJBSko7O0FBTUEsVUFBTWEsd0JBQXdCWiwwQkFBMEJhLEtBQTFCLENBQWdDTCxVQUFoQyxFQUE0Q0UsUUFBNUMsQ0FBOUI7QUFDQSxVQUFNSSw4QkFBOEJiLGlCQUFpQmMsSUFBakIsQ0FBc0JILHFCQUF0QixDQUFwQzs7QUFFQVosa0NBQTRCQSwwQkFBMEJhLEtBQTFCLENBQWdDLENBQWhDLEVBQW1DTCxVQUFuQyxJQUFpRE0sMkJBQWpELEdBQStFZCwwQkFBMEJhLEtBQTFCLENBQWdDSCxRQUFoQyxDQUEzRzs7QUFFQVgsdUNBQWlDZSw0QkFBNEJFLE1BQTVCLEdBQXFDSixzQkFBc0JJLE1BQTVGO0FBQ0Q7QUFDRixHQXBCSDs7QUF1QkE7QUFDQSxNQUFNQyw0QkFBNEIscUNBQ2hDLDRCQURnQyxFQUVoQyxVQUFDZixLQUFELEVBQVFnQixLQUFSO0FBQUEsV0FBa0JBLEtBQWxCO0FBQUEsR0FGZ0MsRUFHaEMsVUFBQ0MsWUFBRDtBQUFBLGdCQUFxQmhELDRCQUFyQixHQUFvRGdELFlBQXBELEdBQW1FL0MsNEJBQW5FO0FBQUEsR0FIZ0MsQ0FBbEM7O0FBTUEsTUFBTWdELDBCQUEwQkgsMEJBQTBCRixJQUExQixDQUErQmYseUJBQS9CLENBQWhDOztBQUVBO0FBQ0EsTUFBSXFCLFdBQVcsc0NBQ1pDLFNBRFksQ0FDRixZQURFLEVBRVpDLE1BRlksQ0FFTCxDQUFDLGFBQUQsQ0FGSyxFQUdaQyxHQUhZLENBR1I7QUFDSDtBQUNBQyxZQUFRLElBRkw7QUFHSEMsaUJBQWEzQyxPQUFPMkMsV0FIakI7QUFJSEMsYUFKRyxxQkFJT0MsSUFKUCxFQUlhQyxZQUpiLEVBSTJCO0FBQzVCLFVBQUlDLDJCQUFKOztBQUVBLDBCQUFZUixTQUFaLENBQXNCLEVBQUVTLFlBQVksSUFBZCxFQUF0Qjs7QUFFQTtBQUNBLFVBQUlGLGdCQUFnQixvQkFBWUcsV0FBWixDQUF3QkgsWUFBeEIsQ0FBcEIsRUFBMkQ7QUFDekQsWUFBSTtBQUNGQywrQkFBcUIsb0JBQVlILFNBQVosQ0FBc0JFLFlBQXRCLEVBQW9DRCxJQUFwQyxFQUEwQ1YsS0FBL0Q7QUFDRCxTQUZELENBRUUsT0FBT2UsR0FBUCxFQUFZLENBQUUsQ0FIeUMsQ0FHeEM7QUFDbEI7O0FBRUQ7QUFDQSxVQUFJLENBQUNILGtCQUFMLEVBQXlCO0FBQ3ZCLFlBQUk7QUFDRkEsK0JBQXFCLG9CQUFZSSxhQUFaLENBQTBCTixJQUExQixFQUFnQ1YsS0FBckQ7QUFDRCxTQUZELENBRUUsT0FBT2UsR0FBUCxFQUFZLENBQUUsQ0FITyxDQUdOO0FBQ2xCOztBQUVELGFBQU9ILG1CQUNKSyxPQURJLENBQ0ksS0FESixFQUNXLFFBRFgsQ0FBUDtBQUVEO0FBekJFLEdBSFEsQ0FBZjs7QUErQkE7QUFDQSxNQUFJcEQsT0FBT0YsaUJBQVAsSUFBNEJ1RCxNQUFNQyxPQUFOLENBQWN0RCxPQUFPRixpQkFBckIsQ0FBaEMsRUFBeUU7QUFDdkV3QyxlQUFXdEMsT0FBT0YsaUJBQVAsQ0FDUnlELE1BRFEsQ0FFUCxVQUFDQyxnQkFBRCxFQUFtQkMsZ0JBQW5CLEVBQXdDO0FBQ3RDLFVBQUksQ0FBQ0osTUFBTUMsT0FBTixDQUFjRyxnQkFBZCxDQUFMLEVBQXNDO0FBQ3BDQSwyQkFBbUIsQ0FBQ0EsZ0JBQUQsQ0FBbkI7QUFDRDtBQUNELFVBQUksT0FBT0EsaUJBQWlCLENBQWpCLENBQVAsS0FBK0IsUUFBbkMsRUFBNkM7QUFDM0NBLHlCQUFpQixDQUFqQixJQUFzQkMsUUFBUUQsaUJBQWlCLENBQWpCLENBQVIsQ0FBdEI7QUFDRDtBQUNELGFBQU9ELGlCQUFpQkcsR0FBakIsNENBQXdCRixnQkFBeEIsRUFBUDtBQUNELEtBVk0sRUFXUG5CLFFBWE8sQ0FBWDtBQWFEOztBQUVEO0FBQ0EsTUFBTXNCLE9BQU8sQ0FDWHRCLFNBQVN1QixNQUFULENBQWdCeEIsdUJBQWhCLEtBQTRDLHlCQURqQyxFQUVYZSxPQUZXLENBR1gsSUFBSVUsTUFBSixDQUFXeEUsNEJBQVgsRUFBeUMsR0FBekMsQ0FIVyxFQUlYLFdBSlcsQ0FBYjs7QUFPQTtBQUNBLE1BQU15RSxjQUFjLENBQUMsQ0FBRCxDQUFwQjs7QUFFQSx3QkFDRUgsSUFERixFQUVFLFVBQUN6QyxLQUFELEVBQVFDLFdBQVIsRUFBcUJDLE1BQXJCLEVBQWdDO0FBQzlCLFFBQUlELFlBQVksQ0FBWixNQUFtQixHQUF2QixFQUE0QjtBQUMxQjtBQUNBMkMsa0JBQVlyRCxJQUFaLENBQWlCVyxNQUFqQjtBQUNELEtBSEQsTUFHTztBQUFFO0FBQ1A7QUFDQTBDLGtCQUFZckQsSUFBWixDQUFpQlcsU0FBU0QsWUFBWWEsTUFBdEM7QUFDRDtBQUNGLEdBVkg7O0FBYUE7QUFDQSxNQUFJK0IsTUFBTUQsWUFDUG5ELEdBRE8sQ0FDSCxVQUFDUyxNQUFELEVBQVM0QyxLQUFULEVBQWdCQyxLQUFoQixFQUEwQjtBQUM3QixRQUFJQyxXQUFXUCxLQUFLOUIsS0FBTCxDQUFXVCxNQUFYLEVBQW1CNkMsTUFBTUQsUUFBUSxDQUFkLENBQW5CLENBQWY7O0FBRUE7QUFDQSxRQUFJRSxTQUFTLENBQVQsTUFBZ0IsR0FBaEIsSUFBdUJBLFNBQVNBLFNBQVNsQyxNQUFULEdBQWtCLENBQTNCLE1BQWtDLEdBQTdELEVBQWtFO0FBQ2hFO0FBQ0EsVUFBSWtDLFNBQVNyQyxLQUFULENBQWUsQ0FBZixFQUFrQixDQUFsQixNQUF5QixNQUE3QixFQUFxQztBQUNuQztBQUNBLHVCQUFhcUMsU0FBU3JDLEtBQVQsQ0FBZSxDQUFmLEVBQWtCLENBQUMsQ0FBbkIsQ0FBYjtBQUNELE9BSEQsTUFHTztBQUNMO0FBQ0EsWUFBSXFDLFNBQVMsQ0FBVCxNQUFnQixHQUFwQixFQUF5QjtBQUN2QjtBQUNBQSxxQkFBV0EsU0FBU2YsT0FBVCxDQUFpQixjQUFqQixFQUFpQyxVQUFqQyxDQUFYOztBQUVBO0FBQ0EsY0FBSXBELE9BQU9ILGdCQUFYLEVBQTZCO0FBQzNCLGdCQUFNdUUsVUFBVUQsU0FBU3JDLEtBQVQsQ0FBZSxDQUFmLEVBQWtCcUMsU0FBU0UsTUFBVCxDQUFnQixRQUFoQixDQUFsQixDQUFoQjs7QUFFQSxtQkFBT0YsU0FBU2YsT0FBVCxDQUNMLFdBREsseUJBRWdCLHdCQUFhZ0IsT0FBYixDQUZoQixVQUFQO0FBSUQ7QUFDRjtBQUNGO0FBQ0YsS0F0QkQsTUFzQk87QUFDTDtBQUNBLGFBQU9ELFNBQVNHLEtBQVQsQ0FBZSxLQUFmLEVBQXNCMUQsR0FBdEIsQ0FBMEIsVUFBQzJELElBQUQsRUFBVTtBQUN6Qzs7QUFFQSxZQUFJQSxLQUFLekQsT0FBTCxDQUFhLEdBQWIsTUFBc0IsQ0FBQyxDQUF2QixJQUE0QnlELEtBQUt6RCxPQUFMLENBQWEsR0FBYixNQUFzQixDQUFDLENBQXZELEVBQTBEO0FBQ3hELHVCQUFXLHdCQUFhLGdCQUFleUQsSUFBZixDQUFiLENBQVg7QUFDRDs7QUFFRCxlQUFPQSxJQUFQO0FBQ0QsT0FSTSxFQVFKQyxJQVJJLENBUUMsSUFSRCxDQUFQO0FBU0Q7O0FBRUQ7QUFDQSxXQUFPTCxRQUFQO0FBQ0QsR0ExQ087QUEyQ1I7QUEzQ1EsR0E0Q1BLLElBNUNPLENBNENGLEVBNUNFO0FBNkNSO0FBN0NRLEdBOENQcEIsT0E5Q08sQ0ErQ04sSUFBSVUsTUFBSixDQUFXdkUsb0NBQVgsRUFBaUQsR0FBakQsQ0EvQ00sRUFnRE4sSUFoRE07QUFrRFI7QUFsRFEsR0FtRFA2RCxPQW5ETyxDQW1EQyxLQW5ERCxFQW1EUSxjQW5EUjtBQW9EUjtBQXBEUSxHQXFEUEEsT0FyRE8sQ0FxREMsU0FyREQsRUFxRFksRUFyRFosQ0FBVjs7QUF1REE7QUFDQVksUUFBTTlDLGlCQUFpQnVELE1BQWpCLENBQXdCdkMsMEJBQTBCdUMsTUFBMUIsQ0FBaUNULEdBQWpDLENBQXhCLENBQU47O0FBRUEsU0FBTyxzQkFDTHhELE9BREssRUFFTEMsT0FGSyxFQUdMdUQsR0FISyxFQUlMaEUsTUFKSyxDQUFQO0FBTUQsQyIsImZpbGUiOiJjb252ZXJ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZyb250TWF0dGVyIGZyb20gJ2Zyb250LW1hdHRlcic7XG5pbXBvcnQgd2Fsa0h0bWwgZnJvbSAnaGFzdG1sJztcbmltcG9ydCB7IGRlY29kZSBhcyBkZWNvZGVFbnRpdGllcyB9IGZyb20gJ2hlJztcbmltcG9ydCBIaWdobGlnaHRKUyBmcm9tICdoaWdobGlnaHQuanMnO1xuaW1wb3J0IE1hcmtkb3duSXQgZnJvbSAnLi9qc3gtZnJpZW5kbHktbWFya2Rvd24taXQnO1xuXG5pbXBvcnQgZm9ybWF0TW9kdWxlIGZyb20gJy4vZm9ybWF0dGVycy9tb2R1bGUnO1xuaW1wb3J0IGZvcm1hdEVzY2FwZSBmcm9tICcuL2Zvcm1hdHRlcnMvanMtZXNjYXBlJztcbmltcG9ydCBTdHJpbmdSZXBsYWNlbWVudENhY2hlIGZyb20gJy4vc3RyaW5nLXJlcGxhY2VtZW50LWNhY2hlJztcblxuY29uc3QgQVNTSUdOTUVOVF9FWFBSRVNTSU9OX1BSRUZJWCA9ICdtY2xBc3NpZ25tZW50QmVnaW5JJztcbmNvbnN0IEFTU0lHTk1FTlRfRVhQUkVTU0lPTl9TVUZGSVggPSAnSUVuZCc7XG5jb25zdCBBU1NJR05NRU5UX0VYUFJFU1NJT05fUkVHRVhQID0gKFxuICAvLyBBc3NpZ25tZW50IEV4cHJlc3Npb24gSURzIGFyZSA1NSBsb3dlci1jYXNlIGNoYXJhY3RlcnMgbG9uZ1xuICBgJHtBU1NJR05NRU5UX0VYUFJFU1NJT05fUFJFRklYfVthLXpdezU1fSR7QVNTSUdOTUVOVF9FWFBSRVNTSU9OX1NVRkZJWH1gXG4pO1xuY29uc3QgQVNTSUdOTUVOVF9FWFBSRVNTSU9OX0NPTU1FTlRfUkVHRVhQID0gKFxuICBgey9cXFxcKigke0FTU0lHTk1FTlRfRVhQUkVTU0lPTl9SRUdFWFB9KVxcXFwqL31gXG4pO1xuXG5jb25zdCBJTVBMSUNJVF9SRUFDVF9JTVBPUlRTID0ge1xuICBSZWFjdDogJ3JlYWN0JyxcbiAgUHJvcFR5cGVzOiAncHJvcC10eXBlcydcbn07XG5cbmNvbnN0IERFRkFVTFRfQ09ORklHVVJBVElPTiA9IHtcbiAgaW1wbGljaXRseUltcG9ydFJlYWN0OiB0cnVlLFxuICBwYXNzRWxlbWVudFByb3BzOiBmYWxzZSxcbiAgbWFya2Rvd25JdFBsdWdpbnM6IFtdXG59O1xuXG5leHBvcnQgZGVmYXVsdCAoc291cmNlLCBjb25maWcpID0+IHtcbiAgLy8gRmlyc3QsIHdlIGhhbmRsZSB0aGUgY29uZmlndXJhdGlvbiBhbmQgZnJvbnQtbWF0dGVyXG5cbiAgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9DT05GSUdVUkFUSU9OLCBjb25maWcpO1xuXG4gIGNvbnN0IGludmFsaWRTdGF0aWNzID0gWydwcm9wVHlwZXMnXTtcblxuICAvLyBQdWxsIG91dCBpbXBvcnRzICYgZnJvbnQtbWF0dGVyXG4gIGNvbnN0IHsgYm9keTogbWFya2Rvd24sIGF0dHJpYnV0ZXM6IHsgaW1wb3J0czogY3VzdG9tSW1wb3J0cywgLi4uc3RhdGljcyB9IH0gPSBmcm9udE1hdHRlcihzb3VyY2UpO1xuXG4gIC8vIEltcG9ydCBSZWFjdCBhbmQgUHJvcFR5cGVzIHVubGVzcyB3ZSd2ZSBiZWVuIGFza2VkIG90aGVyd2lzZVxuICBjb25zdCBpbXBvcnRzID0gY29uZmlnLmltcGxpY2l0bHlJbXBvcnRSZWFjdFxuICAgID8geyAuLi5JTVBMSUNJVF9SRUFDVF9JTVBPUlRTLCAuLi5jdXN0b21JbXBvcnRzIH1cbiAgICA6IGN1c3RvbUltcG9ydHM7XG5cbiAgLy8gRGlzYWxsb3cgcGFzc2luZyBgZGVmYXVsdFByb3BzYCBpZiB3ZSdyZSBwYXNzaW5nIG91ciBvd25cbiAgaWYgKGNvbmZpZy5wYXNzRWxlbWVudFByb3BzKSB7XG4gICAgaW52YWxpZFN0YXRpY3MucHVzaCgnZGVmYXVsdFByb3BzJyk7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgaW52YWxpZCBzdGF0aWNzXG4gIE9iamVjdC5rZXlzKHN0YXRpY3MpLm1hcCgoYXR0cmlidXRlKSA9PiB7XG4gICAgaWYgKGludmFsaWRTdGF0aWNzLmluZGV4T2YoYXR0cmlidXRlKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBjYW4ndCBzdXBwbHkgYSBcXGAke2F0dHJpYnV0ZX1cXGAgc3RhdGljISBUaGF0IG5hbWUgaXMgcmVzZXJ2ZWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIE5vdywgd2Ugc3RhcnQgcHJvY2Vzc2luZyB0aGUgbWFya2Rvd24gaXRzZWxmXG5cbiAgLy8gSG9sZCBvbnRvIEpTWCBwcm9wZXJ0aWVzIGFuZCBhc3NpZ25tZW50IGV4cHJlc3Npb25zIGJlZm9yZSBjb252ZXJ0aW5nXG4gIGxldCBvZmZzZXRGb3JQcm9wZXJ0eVJlcGxhY2VtZW50cyA9IDA7XG4gIGxldCBtYXJrZG93blNhbnNKc3hQcm9wZXJ0aWVzID0gbWFya2Rvd247XG5cbiAgY29uc3QganN4UHJvcGVydHlDYWNoZSA9IG5ldyBTdHJpbmdSZXBsYWNlbWVudENhY2hlKFxuICAgIC9bXFx3XSs9e1tefV0qfVxccyp9P3x7XFxzKlxcLlxcLlxcLltefV0qfS9nXG4gICk7XG5cbiAgLy8gRmluZCBhbGwgb3BlbmluZyBvciB2b2lkIEhUTUwgdGFnc1xuICB3YWxrSHRtbChcbiAgICBtYXJrZG93bixcbiAgICAobWF0Y2gsIHRhZ0ZyYWdtZW50LCBvZmZzZXQsIHN0cmluZywgdGFnKSA9PiB7XG4gICAgICAvLyBPbmNlIHdlIGdldCBhIHRhZyB3aGljaCBpcyBjbG9zaW5nXG4gICAgICBpZiAodHlwZW9mIHRhZy5jbG9zZUluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBSZXBsYWNlIGFueSBhc3NpZ25tZW50IGV4cHJlc3Npb25zIHdpdGhpbiBpdHMgb3BlbmluZyB0YWdcbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IHRhZy5vcGVuSW5kZXggKyBvZmZzZXRGb3JQcm9wZXJ0eVJlcGxhY2VtZW50cztcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSAoXG4gICAgICAgICAgdHlwZW9mIHRhZy5jb250ZW50SW5kZXggPT09ICdudW1iZXInXG4gICAgICAgICAgICA/IHRhZy5jb250ZW50SW5kZXhcbiAgICAgICAgICAgIDogdGFnLmNsb3NlSW5kZXhcbiAgICAgICAgKSArIG9mZnNldEZvclByb3BlcnR5UmVwbGFjZW1lbnRzO1xuXG4gICAgICAgIGNvbnN0IHRhZ1dpdGhOb1JlcGxhY2VtZW50cyA9IG1hcmtkb3duU2Fuc0pzeFByb3BlcnRpZXMuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICBjb25zdCB0YWdXaXRoUHJvcGVydHlSZXBsYWNlbWVudHMgPSBqc3hQcm9wZXJ0eUNhY2hlLmxvYWQodGFnV2l0aE5vUmVwbGFjZW1lbnRzKTtcblxuICAgICAgICBtYXJrZG93blNhbnNKc3hQcm9wZXJ0aWVzID0gbWFya2Rvd25TYW5zSnN4UHJvcGVydGllcy5zbGljZSgwLCBzdGFydEluZGV4KSArIHRhZ1dpdGhQcm9wZXJ0eVJlcGxhY2VtZW50cyArIG1hcmtkb3duU2Fuc0pzeFByb3BlcnRpZXMuc2xpY2UoZW5kSW5kZXgpO1xuXG4gICAgICAgIG9mZnNldEZvclByb3BlcnR5UmVwbGFjZW1lbnRzICs9IHRhZ1dpdGhQcm9wZXJ0eVJlcGxhY2VtZW50cy5sZW5ndGggLSB0YWdXaXRoTm9SZXBsYWNlbWVudHMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgKTtcblxuICAvLyBSZXBsYWNlIGFsbCByZW1haW5pbmcgZG91YmxlLWJyYWNlIGFzc2lnbm1lbnQgZXhwcmVzc2lvbnMgd2l0aCBjb21tZW50c1xuICBjb25zdCBhc3NpZ25tZW50RXhwcmVzc2lvbkNhY2hlID0gbmV3IFN0cmluZ1JlcGxhY2VtZW50Q2FjaGUoXG4gICAgL3soe1xccyooPzo8Lio/PnwuKj8pXFxzKn0pfS9nLFxuICAgIChtYXRjaCwgdmFsdWUpID0+IHZhbHVlLFxuICAgIChpZGVudGl0eUhhc2gpID0+IGAke0FTU0lHTk1FTlRfRVhQUkVTU0lPTl9QUkVGSVh9JHtpZGVudGl0eUhhc2h9JHtBU1NJR05NRU5UX0VYUFJFU1NJT05fU1VGRklYfWBcbiAgKTtcblxuICBjb25zdCBtYXJrZG93blNhbnNBc3NpZ25tZW50cyA9IGFzc2lnbm1lbnRFeHByZXNzaW9uQ2FjaGUubG9hZChtYXJrZG93blNhbnNKc3hQcm9wZXJ0aWVzKTtcblxuICAvLyBDb25maWd1cmUgTWFya2Rvd24gcmVuZGVyZXIsIGhpZ2hsaWdodCBjb2RlIHNuaXBwZXRzLCBhbmQgcG9zdC1wcm9jZXNzXG4gIGxldCByZW5kZXJlciA9IG5ldyBNYXJrZG93bkl0KClcbiAgICAuY29uZmlndXJlKCdjb21tb25tYXJrJylcbiAgICAuZW5hYmxlKFsnc21hcnRxdW90ZXMnXSlcbiAgICAuc2V0KHtcbiAgICAgIC8vIFdlIG5lZWQgZXhwbGljaXQgbGluZSBicmVha3NcbiAgICAgIGJyZWFrczogdHJ1ZSxcbiAgICAgIHR5cG9ncmFwaGVyOiBjb25maWcudHlwb2dyYXBoZXIsXG4gICAgICBoaWdobGlnaHQoY29kZSwgbGFuZ3VhZ2VIaW50KSB7XG4gICAgICAgIGxldCBoaWdobGlnaHRlZENvbnRlbnQ7XG5cbiAgICAgICAgSGlnaGxpZ2h0SlMuY29uZmlndXJlKHsgdGFiUmVwbGFjZTogJyAgJyB9KTtcblxuICAgICAgICAvLyBUcnkgaGlnaGxpZ2h0aW5nIHdpdGggYSBnaXZlbiBoaW50XG4gICAgICAgIGlmIChsYW5ndWFnZUhpbnQgJiYgSGlnaGxpZ2h0SlMuZ2V0TGFuZ3VhZ2UobGFuZ3VhZ2VIaW50KSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBoaWdobGlnaHRlZENvbnRlbnQgPSBIaWdobGlnaHRKUy5oaWdobGlnaHQobGFuZ3VhZ2VIaW50LCBjb2RlKS52YWx1ZTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhpZ2hsaWdodCB3aXRob3V0IGEgaGludFxuICAgICAgICBpZiAoIWhpZ2hsaWdodGVkQ29udGVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBoaWdobGlnaHRlZENvbnRlbnQgPSBIaWdobGlnaHRKUy5oaWdobGlnaHRBdXRvKGNvZGUpLnZhbHVlO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodGVkQ29udGVudFxuICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJzxiciAvPicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIC8vIExvYWQgTWFya2Rvd25JdCBwbHVnaW5zXG4gIGlmIChjb25maWcubWFya2Rvd25JdFBsdWdpbnMgJiYgQXJyYXkuaXNBcnJheShjb25maWcubWFya2Rvd25JdFBsdWdpbnMpKSB7XG4gICAgcmVuZGVyZXIgPSBjb25maWcubWFya2Rvd25JdFBsdWdpbnNcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChtYXJrZG93blJlbmRlcmVyLCBwbHVnaW5EZWZpbml0aW9uKSA9PiB7XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBsdWdpbkRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICBwbHVnaW5EZWZpbml0aW9uID0gW3BsdWdpbkRlZmluaXRpb25dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHBsdWdpbkRlZmluaXRpb25bMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwbHVnaW5EZWZpbml0aW9uWzBdID0gcmVxdWlyZShwbHVnaW5EZWZpbml0aW9uWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1hcmtkb3duUmVuZGVyZXIudXNlKC4uLnBsdWdpbkRlZmluaXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICByZW5kZXJlclxuICAgICAgKTtcbiAgfVxuXG4gIC8vIFJlbmRlciBtYXJrZG93biB0byBIVE1MLCBhbmQgcmVwbGFjZSBhc3NpZ25tZW50IGV4cHJlc3Npb25zIHdpdGggY29tbWVudHNcbiAgY29uc3QgaHRtbCA9IChcbiAgICByZW5kZXJlci5yZW5kZXIobWFya2Rvd25TYW5zQXNzaWdubWVudHMpIHx8ICc8IS0tIG5vIGlucHV0IGdpdmVuIC0tPidcbiAgKS5yZXBsYWNlKFxuICAgIG5ldyBSZWdFeHAoQVNTSUdOTUVOVF9FWFBSRVNTSU9OX1JFR0VYUCwgJ2cnKSxcbiAgICAnPCEtLSQmLS0+J1xuICApO1xuXG4gIC8vIENvbGxlY3QgYWxsIHRoZSBIVE1MIHRhZ3MgYW5kIHRoZWlyIHBvc2l0aW9uc1xuICBjb25zdCBodG1sT2Zmc2V0cyA9IFswXTtcblxuICB3YWxrSHRtbChcbiAgICBodG1sLFxuICAgIChtYXRjaCwgdGFnRnJhZ21lbnQsIG9mZnNldCkgPT4ge1xuICAgICAgaWYgKHRhZ0ZyYWdtZW50WzBdID09PSAnPCcpIHtcbiAgICAgICAgLy8gUHVzaCB0aGUgb2Zmc2V0IG9mIG9wZW5pbmcgdGFncy4uLlxuICAgICAgICBodG1sT2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgICB9IGVsc2UgeyAvLyDiiLQgdGFnRnJhZ21lbnRbdGFnRnJhZ21lbnQubGVuZ3RoIC0gMV0gPT09ICc+J1xuICAgICAgICAvLyAuLi5hbmQgdGhlIGVuZCBvZmZzZXQgb2YgY2xvc2luZyB0YWdzXG4gICAgICAgIGh0bWxPZmZzZXRzLnB1c2gob2Zmc2V0ICsgdGFnRnJhZ21lbnQubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG5cbiAgLy8gSGVyZSwgd2UgY29sbGVjdCBhbGwgdGhlIHBvc2l0aW9ucyBhdCB3aGljaCBIVE1MIHRhZ3MgYmVnaW4gb3IgZW5kXG4gIGxldCBqc3ggPSBodG1sT2Zmc2V0c1xuICAgIC5tYXAoKG9mZnNldCwgaW5kZXgsIGFycmF5KSA9PiB7XG4gICAgICBsZXQgZnJhZ21lbnQgPSBodG1sLnNsaWNlKG9mZnNldCwgYXJyYXlbaW5kZXggKyAxXSk7XG5cbiAgICAgIC8vIFRoZW4gd2UgY2hlY2ssIGZvciBlYWNoIG9mIHRoZW0sIHdoZXRoZXIgdGhleSBhcmUgYSB0YWcgb3IgYSB0ZXh0IG5vZGVcbiAgICAgIGlmIChmcmFnbWVudFswXSA9PT0gJzwnIHx8IGZyYWdtZW50W2ZyYWdtZW50Lmxlbmd0aCAtIDFdID09PSAnPicpIHtcbiAgICAgICAgLy8gSWYgdGhleSdyZSB0YWdzLCB3ZSBjaGVjayB3aGV0aGVyIHRoZXkncmUgYSBjb21tZW50LFxuICAgICAgICBpZiAoZnJhZ21lbnQuc2xpY2UoMCwgNCkgPT09ICc8IS0tJykge1xuICAgICAgICAgIC8vIGFuZCByZXBsYWNlIHRoZW0gd2l0aCBKU1ggc3R5bGUgY29tbWVudHNcbiAgICAgICAgICByZXR1cm4gYHsvKiR7ZnJhZ21lbnQuc2xpY2UoNCwgLTMpfSovfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlLCB3ZSB3aWxsLi4uXG4gICAgICAgICAgaWYgKGZyYWdtZW50WzFdICE9PSAnLycpIHtcbiAgICAgICAgICAgIC8vIC4uLnJlcGxhY2UgYGNsYXNzYCBwcm9wZXJ0aWVzIHdpdGggYGNsYXNzTmFtZWAgZm9yIFJlYWN0IGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQucmVwbGFjZSgvKFxcc2NsYXNzKSg9KS8sICckMU5hbWUkMicpO1xuXG4gICAgICAgICAgICAvLyBhbmQsIGlmIHdlJ3ZlIGJlZW4gYXNrZWQgdG8sIGFkZCB0aGUgYGVsZW1lbnRQcm9wc2AgcGFzcy10aHJvdWdoLlxuICAgICAgICAgICAgaWYgKGNvbmZpZy5wYXNzRWxlbWVudFByb3BzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBmcmFnbWVudC5zbGljZSgxLCBmcmFnbWVudC5zZWFyY2goL1tcXHNcXG5dLykpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC8oXFxzKlxcLz8+KS8sXG4gICAgICAgICAgICAgICAgYCB7Li4uZWxlbWVudFByb3BzWyR7Zm9ybWF0RXNjYXBlKHRhZ05hbWUpfV19JDFgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGV5J3JlIG5vdCB0YWdzLCB0aGV5J3JlIGEgdGV4dCBub2RlLiBXZSBzcGxpdCBvbiBuZXdsaW5lcywgYW5kLi4uXG4gICAgICAgIHJldHVybiBmcmFnbWVudC5zcGxpdCgvXFxuL2cpLm1hcCgobGluZSkgPT4ge1xuICAgICAgICAgIC8vIC4uLndyYXAgc3RyaW5nIGxpbmVzIGNvbnRhaW5pbmcgY3VybHkgYnJhY2VzXG5cbiAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCd7JykgIT09IC0xIHx8IGxpbmUuaW5kZXhPZignfScpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGB7JHtmb3JtYXRFc2NhcGUoZGVjb2RlRW50aXRpZXMobGluZSkpfX1gO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gZmFsbCBiYWNrIHRvIHJldHVybmluZyBpbnB1dFxuICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH0pXG4gICAgLy8gUHV0IGl0IGFsbCBiYWNrIHRvZ2V0aGVyLFxuICAgIC5qb2luKCcnKVxuICAgIC8vIFJlc3RvcmUgYXNzaWdubWVudCBleHByZXNzaW9ucyB0byB0aGVpciBvcmlnaW5hbCBmb3JtXG4gICAgLnJlcGxhY2UoXG4gICAgICBuZXcgUmVnRXhwKEFTU0lHTk1FTlRfRVhQUkVTU0lPTl9DT01NRU5UX1JFR0VYUCwgJ2cnKSxcbiAgICAgICckMSdcbiAgICApXG4gICAgLy8gSW5kZW50IGZvciBwcmV0dHkgaW5zcGVjdG9yIG91dHB1dCDwn46JXG4gICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxuICAgICAgICAgICcpXG4gICAgLy8gQW5kIHJlbW92ZSB0aGUgdHJhaWxpbmcgYmxhbmsgbGluZVxuICAgIC5yZXBsYWNlKC9cXG5cXHMqJC9nLCAnJyk7XG5cbiAgLy8gVW5sb2FkIGNhY2hlcyBzbyB3ZSd2ZSBnb3Qgb3VyIHZhbHVlcyBiYWNrIVxuICBqc3ggPSBqc3hQcm9wZXJ0eUNhY2hlLnVubG9hZChhc3NpZ25tZW50RXhwcmVzc2lvbkNhY2hlLnVubG9hZChqc3gpKTtcblxuICByZXR1cm4gZm9ybWF0TW9kdWxlKFxuICAgIGltcG9ydHMsXG4gICAgc3RhdGljcyxcbiAgICBqc3gsXG4gICAgY29uZmlnXG4gICk7XG59O1xuIl19